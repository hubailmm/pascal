###############################################################################
#                                                                              #
#   sa2d_decomp_value.py copyright(c) Qiqi Wang 2015 (qiqi.wang@gmail.com)     #
#                                                                              #
################################################################################

import sys
import time
import collections
import copy as copymodule

import numpy as np
import pulp
import graphviz


def _is_like_sa_value(a):
    '''
    Check attributes of stencil array value
    '''
    if hasattr(a, 'owner'):
        return a.owner is None or hasattr(a.owner, 'access_neighbor')
    else:
        return False

# ============================================================================ #
#                             stencil_array value                              #
# ============================================================================ #

class stencil_array_value(object):
    def __init__(self, shape=(), owner=None):
        self.shape = tuple(shape)
        self.owner = owner

    def __repr__(self):
        if self.owner:
            return 'Dependent value of shape {0} generated by {1}'.format(
                    self.shape, self.owner)
        else:
            return 'Independent value of shape {0}'.format(self.shape)

    # --------------------------- properties ------------------------------ #

    @property
    def ndim(self):
        return len(self.shape)

    @property
    def size(self):
        return int(np.prod(self.shape))

    def __len__(self):
        return 1 if not self.shape else self.shape[0]


class builtin:
    ZERO = stencil_array_value()
    I = stencil_array_value()
    J = stencil_array_value()
    K = stencil_array_value()


# ============================================================================ #
#                                atomic stage                                  #
# ============================================================================ #

def discover_values(source_values, sink_values):
    discovered_values = []
    discovered_triburary_values = []
    def discover_values_from(v):
        if not hasattr(v, 'owner'):
            return
        if v in source_values:
            return
        if v.owner is None:
            if v not in discovered_triburary_values:
                discovered_triburary_values.append(v)
        elif v not in discovered_values:
            discovered_values.append(v)
            for v_inp in v.owner.inputs:
                discover_values_from(v_inp)
    for v in sink_values:
        discover_values_from(v)
    return discovered_values, discovered_triburary_values

def sort_values(sorted_values, unsorted_values):
    def is_computable(v):
        return (not _is_like_sa_value(v) or
                v in sorted_values or
                v.owner is None)
    while len(unsorted_values):
        removed_any = False
        for v in unsorted_values:
            if all([is_computable(v_inp) for v_inp in v.owner.inputs]):
                unsorted_values.remove(v)
                sorted_values.append(v)
                removed_any = True
        assert removed_any

class AtomicStage(object):
    '''
    Immutable compact stage
    '''
    def __init__(self, source_values, sink_values):
        sorted_values = copymodule.copy(source_values)
        unsorted_values, self.triburary_values = discover_values(
                source_values, sink_values)
        sort_values(sorted_values, unsorted_values)
        assert unsorted_values == []
        self.source_values = sorted_values[:len(source_values)]
        self.sorted_values = sorted_values[len(source_values):]
        self.sink_values = copymodule.copy(sink_values)

    def __call__(self, source_values, triburary):
        if not isinstance(source_values, (tuple, list)):
            source_values = [source_values]
        source_values = list(source_values)
        assert len(self.source_values) == len(source_values)
        if hasattr(triburary, '__call__'):
            triburary_values = [triburary(v) for v in self.triburary_values]
        elif hasattr(triburary, '__getitem__'):
            triburary_values = [triburary[v] for v in self.triburary_values]
        values = self.source_values + self.triburary_values
        tmp_values = source_values + triburary_values
        # _tmp attributes are assigned to inputs
        assert len(values) == len(tmp_values)
        for v, v_tmp in zip(values, tmp_values):
            assert not hasattr(v, '_tmp')
            v._tmp = v_tmp
        # _tmp attributes are computed to each value
        _tmp = lambda v : v._tmp if _is_like_sa_value(v) else v
        for v in self.sorted_values:
            assert not hasattr(v, '_tmp')
            inputs_tmp = [_tmp(v_inp) for v_inp in v.owner.inputs]
            v._tmp = v.owner.perform(inputs_tmp)
        # _tmp attributes are extracted from outputs then deleted from all
        sink_values = tuple(v._tmp for v in self.sink_values)
        values += self.sorted_values
        for v in values:
            del v._tmp
        return sink_values

    def __hash__(self):
        return id(self)

# ============================================================================ #
#                                decomposition                                 #
# ============================================================================ #

_LP = collections.namedtuple('LP', 'c, bounds, A_eq, A_le, b_eq, b_le')
_LPRes = collections.namedtuple('LPRes', 'x, obj, status')

GLOBAL_MAX_STAGES = -1

# ---------------------------------------------------------------------------- #

def _build_linear_program(all_values, source_values, sink_values):
    '''
    solution: [c, k, g, K]
    c: length n array of integers, the stage in which a value is created;
    k: length n array of integers, the stage in which a value is killed;
    g: length n array of 0 and 1's, bareness of array,
       1 indicating it is bare, i.e, has no neighbors upon creation;
       0 indicating it has one layer of neighbor upon creation.
    '''
    def add_eq(A_c, A_k, A_g, A_K, b):
        A_eq.append(np.hstack([A_c, A_k, A_g, A_K]))
        b_eq.append(b)

    def add_le(A_c, A_k, A_g, A_K, b):
        A_le.append(np.hstack([A_c, A_k, A_g, A_K]))
        b_le.append(b)

    n = len(all_values)
    A_eq, A_le, b_eq, b_le = [], [], [], []
    # build bounds
    non_negative = (0, GLOBAL_MAX_STAGES)
    bounds = [non_negative] * (2 * n) + [(0, 1)] * n + [non_negative]
    # build constraints
    z = np.zeros(n)
    e = np.eye(n)
    for a in source_values:
        i = a._valueId
        # an input value is born at Stage 0
        add_eq(e[i], z, z, 0, 0)
    for a in sink_values:
        i = a._valueId
        # an output value is killed at Stage K (last stage)
        add_eq(z, e[i], z, -1, 0)
    for a in all_values:
        i = a._valueId
        # a value cannot be killed before it is born
        add_le(e[i], -e[i], z, 0, 0)
        if a.owner:
            for b in a.owner.inputs:
                if _is_like_sa_value(b):
                    assert b in all_values
                    j = b._valueId
                    # a child cannot be born before its parent is born
                    add_le(e[j] - e[i], z, z, 0, 0)
                    # a child cannot be born after its parent is killed
                    add_le(e[i], -e[j], z, 0, 0)
                    if a.owner.access_neighbor:
                        # a bare parent must wait to next stage
                        # to produce any child through neibhor access
                        add_le(e[j] - e[i], z, e[j] - e[i], 0, -1)
                    else:
                        # a bare parent produces bare children
                        # during its creating stage
                        add_le(e[j] - e[i], z, e[j] - e[i], 0, 0)
            if a.owner.access_neighbor:
                # a child born through neighbor access is bare
                add_eq(z, z, e[i], 0, 1)
    w = np.array([a.size for a in all_values])
    c = np.hstack([-w, w, z, 0])
    return _LP(np.array(c, float), np.array(bounds, float),
               np.array(A_eq, float), np.array(A_le, float),
               np.array(b_eq, float), np.array(b_le, float))

# ---------------------------------------------------------------------------- #

def _solve_linear_program_glpk(linear_program, verbose):
    c, bounds, A_eq, A_le, b_eq, b_le = linear_program
    lp = pulp.LpProblem("Decomposition", pulp.LpMinimize)
    # add the variables
    x = []
    for i, (l, u) in enumerate(bounds):
        if u == GLOBAL_MAX_STAGES:
            x.append(pulp.LpVariable('x'+str(i), l, None))
        else:
            x.append(pulp.LpVariable('x'+str(i), l, u))
    # specify the objective
    assert len(x) == len(c)
    lp += pulp.LpAffineExpression([(x[i], c[i]) for i in range(len(x))])
    # add the constraints
    for i in range(b_le.size):
        j, = A_le[i].nonzero()
        expr = pulp.LpAffineExpression([(x[jj], A_le[i, jj]) for jj in j])
        lp += pulp.LpConstraint(expr, pulp.LpConstraintLE, rhs=b_le[i])
    for i in range(b_eq.size):
        j, = A_eq[i].nonzero()
        expr = pulp.LpAffineExpression([(x[jj], A_eq[i, jj]) for jj in j])
        lp += pulp.LpConstraint(expr, pulp.LpConstraintEQ, rhs=b_eq[i])
    # solve with GLPK
    s = pulp.GLPK(mip=0, msg=int(verbose > 1))
    s.actualSolve(lp)
    # extract solution
    x = [pulp.value(xi) for xi in x]
    assert all([abs(xi - round(xi)) < 1E-12 for xi in x]), \
           'Linear Program Finished with non-integer results'
    x = np.array(np.around(x), int)
    objective = int(round(pulp.value(lp.objective)))
    status = pulp.LpStatus[lp.status]
    return _LPRes(x, objective, status)

# ---------------------------------------------------------------------------- #

def _solve_linear_program(linear_program, verbose):
    if verbose:
        lpSize = (len(linear_program.c),
                  len(linear_program.b_eq) + len(linear_program.b_le))
        print('\nDecomposing update formula')
        print('\tsolving {0}x{1} linear program'.format(*lpSize))
        sys.stdout.flush()
        t0 = time.time()
    res = _solve_linear_program_glpk(linear_program, verbose==True)
    if verbose:
        print('Decomposed into {0} atomic stages'.format(res.x[-1] + 1))
        print('\tobjective function = {0}'.format(res.obj))
        print('\tstatus: ' + res.status)
        print('\ttime: {0:f}'.format(time.time() - t0))
        sys.stdout.flush()
    return res

# ---------------------------------------------------------------------------- #

def _assign_lp_results_to_values(lp_result, values):
    c, k, g = lp_result.x[:-1].reshape([3,-1])
    assert c.size == len(values)
    assert g.max() <= 1
    for i, a in enumerate(values):
        a = values[i]
        a.create_stage = int(round(c[i]))
        a.kill_stage = int(round(k[i]))
        a.has_neighbor = (round(g[i]) == 0)
    num_stages = int(lp_result.x[-1]) + 1
    return num_stages

# ---------------------------------------------------------------------------- #

def visualize_graph(filename, source_values, sink_values,
                    view=True, color=None):
    sorted_values = list(copymodule.copy(source_values))
    unsorted_values, triburary_values = discover_values(
            source_values, sink_values)
    sort_values(sorted_values, unsorted_values)
    assert unsorted_values == []
    dot = graphviz.Digraph(graph_attr={'rankdir': 'LR'})
    for i, v in enumerate(triburary_values + sorted_values):
        argv = {}
        if hasattr(v, 'has_neighbor') and v.has_neighbor:
            argv['shape'] = 'doublecircle'
        if v in triburary_values:
            argv['shape'] = 'square'
        dot.node(str(i), **argv)
        v._valueId = i
        if hasattr(v, 'owner') and v.owner:
            for inp in v.owner.inputs:
                if _is_like_sa_value(inp):
                    argv = {'penwidth': '3'}
                    if hasattr(v, 'create_stage'):
                        argv['colorscheme'] = 'set19'
                        argv['color'] = str(v.create_stage + 1)
                    elif color is not None:
                        argv['colorscheme'] = 'set19'
                        argv['color'] = str(color + 1)
                    else:
                        argv['color'] = 'black'
                    if v.owner.access_neighbor:
                        argv['arrowsize'] = '3'
                        argv['color'] = '{0}:white:{0}:white:{0}'.format(
                                argv['color'])
                    dot.edge(str(inp._valueId), str(i), **argv)
    for v in triburary_values + sorted_values:
        del v._valueId
    dot.render(filename, view=view)

# ---------------------------------------------------------------------------- #

def decompose(source_values, sink_values, verbose=True):
    if verbose == 'visualize':
        visualize_graph('input.gv', source_values, sink_values, False)
    values, triburary_values = discover_values(
            source_values, sink_values)
    all_values = (list(values) +
                  list(triburary_values) +
                  list(source_values))
    for i, v in enumerate(all_values):
        v._valueId = i
    lp = _build_linear_program(all_values, source_values, sink_values)
    lp_res = _solve_linear_program(lp, verbose)
    for v in all_values:
        del v._valueId
    num_stages = _assign_lp_results_to_values(lp_res, all_values)
    if verbose == 'visualize':
        visualize_graph('color.gv', source_values, sink_values, False)
    stages = []
    stage_source = list(source_values)
    for k in range(1, num_stages):
        stage_sink = [v for v in all_values
                            if v.create_stage < k and v.kill_stage >= k]
        stages.append(AtomicStage(stage_source, stage_sink))
        stage_source = stage_sink
    stage_sink = list(sink_values)
    stages.append(AtomicStage(stage_source, stage_sink))
    return stages

################################################################################
################################################################################
################################################################################
