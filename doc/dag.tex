\documentclass[12pt]{article}
\usepackage{amsmath, amssymb, amsfonts, fullpage, color}
\usepackage[procnames]{listings}

\title{An algorithm for decomposing a stencil update formula into atomic stages}
\author{Qiqi Wang}

\definecolor{keywords}{RGB}{150,100,0}
\definecolor{comments}{RGB}{0,0,100}
\definecolor{red}{RGB}{150,0,0}
\definecolor{green}{RGB}{0,100,0}
\definecolor{lightgray}{RGB}{240,240,240}
\lstset{language=Python, 
        backgroundcolor=\color{lightgray},
        basicstyle=\ttfamily\footnotesize, 
        keywordstyle=\color{keywords},
        commentstyle=\color{comments},
        stringstyle=\color{red},
        showstringspaces=false,
        identifierstyle=\color{green},
        procnamekeys={def,class}}

\begin{document}
\maketitle

\section{Introduction}
When performing a variety of simulations, we discretize space into grid points, and time into time steps.  The resulting discretized equation often updates a few variables every time step, follwing an identical update formula.  For example, conduction of heat in materials, often modeled by the heat equation
\begin{equation}
\frac{\partial u}{\partial t} = \frac{\partial^2 u}{\partial x^2},
\end{equation}
can be simulated with the update formula
\begin{equation} \label{update00}
u_i^{n+1} = u_i^n + \Delta t \frac{u_{i-1}^n - 2 u_i^n + u_{i+1}^n}{\Delta x^2},
\end{equation}
where subscript $i$ denotes spatial grid point, and superscript $n$ denotes time step.  The set of neighboring grid points involved, $\{i-1, i, i+1\}$, is called the stencil of this update formula.
This update formula is derived through tedious manipulation of Taylor serieses, formally by approximating the spatial derivative with a linear combination of neighboring values, a technique known as finite difference, in conjunction with a time advancing method called forward Euler.
This update formula can be described as the following function
\begin{lstlisting}
def heat(u0):
    return u0 + Dt/Dx**2 * (u0.x_m - 2*u0 + u0.x_p)
\end{lstlisting}
The same stencil update formula (\ref{update00}) is applied at every grid point $i$, for every time step $n$.

We can solve a wide variety of problems by applying identical stencil update formulas, at all grid points in a spatial domain, for all time steps in a time interval.  More complex update formulas are often used to increase the accuracy, or to solve more complex equations.
To increase the accuracy for solving the same heat equation, for example, one may upgrade the time advancing method from forward Euler to the midpoint method.  Also known as the second-order Runge-Kutta, it is derived through simply more tedious manipulation of Taylor serieses.  The resulting update formula is
\begin{equation}
\begin{aligned}
u_i^{n+\frac12} &= u_i^n + \frac{\Delta t}2 \frac{u_{i-1}^n - 2 u_i^n + u_{i+1}^n}{\Delta x^2}, \\
u_i^{n+1} &= u_i^n + \Delta t \frac{u_{i-1}^{n+\frac12} - 2 u_i^{n+\frac12} + u_{i+1}^{n+\frac12}}{\Delta x^2}.
\end{aligned}
\end{equation}
Because $u_i^{n+1}$ depends on $u_{i-2}^n$ and $u_{i+2}^n$, the stencil of this update formula is $\{i-2,i-1,i,i+1,i+2\}$.
This update formula can be described as the following function
\begin{lstlisting}
def heatMidpoint(u0):
    uHalf = u0 + Dt/Dx**2/2 * (u0.x_m - 2*u0 + u0.x_p)
    return u0 + Dt/Dx**2 * (uHalf.x_m - 2*uHalf + uHalf.x_p)
\end{lstlisting}
An example of a more complex equation is the following one with a fourth order spatial derivative, which often appears in structural simulations:
\begin{equation}
\frac{\partial u}{\partial t} = \frac{\partial^4 u}{\partial x^4}.
\end{equation}
Using even more tedious manipulation of Taylor serieses, we can derive the following update formula
\begin{equation} \label{update02}
\begin{aligned}
v_i^n &= u_{i-1}^n - 2 u_i^n + u_{i+1}^n, \\
u_i^{n+1} &= u_i^n + \Delta t \frac{v_{i-1}^n - 2 v_i^n + v_{i+1}^n}{\Delta x^4}.
\end{aligned}
\end{equation}
This update formula can be described as the following function
\begin{lstlisting}
def fourthOrderPde(u0):
    v0 = u0.x_m - 2*u0 + u0.x_p
    return u0 + Dt/Dx**4 * (v0.x_m - 2*v0 + v0.x_p)
\end{lstlisting}
Many applied mathematicians labored for years to derive such updating formulas to simulate various problems.  To make them accurate, stable, flexible, and apealing in other aspects, they can craft update formulae that are hundreds of times more complex than those in our examples.  However complex an update formula can be, it uses a number of inputs at every grid points, and produces the same number of outputs.  These outputs depend on the inputs at a stencil, i.e., a neighboring set of grid points.  The update formula is applied identically, at every grid point, for every time step.

We can decompose a complex update formula into a sequence of stages, such that
\begin{enumerate}
\item Each stage is ``atomic'', which means that the output depends on the inputs only at the immediate neighboring grid points.
\item Each stage generates outputs that matches the inputs of the next stage.
\item The inputs of the first stage and the outputs of the last stage matche the inputs and ouputs of the entire update formula.
\end{enumerate}
Our first example, Formula (\ref{update00}), is a single atomic stage.  The input of the stage is $u_i^n$, and the output is $u_i^{n+1}$.  Two atomic stages naturually form Update formula (\ref{update01}).  The input of the first stage is $u_i^n$, and the outputs include $u_i^{n+\frac12}$ and $u_i^{n}$
itself.  These outputs must be the inputs of the next stage, whose output is $u_i^{n+1}$.  The stages can be described as
\begin{lstlisting}
def heatMidpoint_stage0(u0):
    uHalf = u0 + Dt/Dx**2/2 * (u0.x_m - 2*u0 + u0.x_p)
    return u0, uHalf

def heatMidpoint_stage1(inputs):
    u0, uHalf = inputs
    return u0 + Dt/Dx**2 * (uHalf.x_m - 2*uHalf + uHalf.x_p)
\end{lstlisting}

Update formula (\ref{update02}) also decomposes into two statges.  The first stage has input $u_i^n$, and outputs $(u_i^n, v_i^n)$.  The second stage has inputs $(u_i^n, v_i^n)$, and output $u_i^{n+1}$.  The stages can be described as
\begin{lstlisting}
def fourthOrderPde_stage0(u0):
    v0 = u0.x_m - 2*u0 + u0.x_p
    return u0, v0

def fourthOrderPde_stage1(inputs):
    u0, v0 = inputs
    return u0 + Dt/Dx**4 * (v0.x_m - 2*v0 + v0.x_p)
\end{lstlisting}
Many update formulae can be decomposed into a sequence of atomic stages, such that the outputs of each stage is the inputs of the next.  Automating such decomposition is the goal of this paper.

Why should we decompose a stencil update formula into atomic stages?  This is most often desirable if the simulation runs on massively parallel computers.  Processors in such computers must communicate often to complete a simulation.  These communications can be simplified if it occurs in between consequtive atomic stages.  Some parallel computing methods, such as the swept decomposition scheme, even requires atomic decomposition of update formulae.

\section{Finding a good decomposition}

A good decomposition, first of all, consists of as few stages as possible.
Though not obvious, this first criteria is implied by the second
criteria, minimization of the variables that pass between stages.  Here a variable is said to pass between stages if it is created in one stage, and is last used, or killed, in a later stage.  This variable must be among the outputs of its creation stage and the inputs of its killing stage.  It also must be among both the inputs and outputs of all stages in between its creation and killing stages.  The more variables pass between stages, the more data must be communicated in between these stages.  To quantify this criterion, we assign an index $i$ to every intermediate varialbe in the update formula.  We denote $c_i$ as the stage in which if Variable $i$ is created, and $k_i$ as the stage in which Variable $i$ is killed.  We want to minimize
\begin{equation} \label{obj0}
\min \sum_i (k_i - c_i) w_i,
\end{equation}
where $w_i$ is the amount of data contained in variable $i$ at every grid point.  Some variables, such as a velocity vector, contains more data than other variables, such as density.  We assume that $w_i$ is known for every variable.

To form a linear program that minimizes (\ref{obj0}),
we introduce another unknown $g_i$ for each variable.
$g_i$ can either be 0 or 1, depending on the value of $c_i$.
If Variable $i$ depends on the inputs of Stage $c_i$ only at the current grid point, then $g_i=0$; if it can depends on the inputs also at the neighboring grid points, then $g_i=1$.  Because every stage is atomic, Variable $i$ cannot depend on the inputs of Stage $c_i$ at more than the immediate neighboring grid points.

Here lists the constraints of the linear program:
\begin{enumerate}
\item
$c_i = 0$ if Variable $i$ is an input of the entire update formula.
All inputs are created in the first stage.
\item
$k_i = K$ if Variable $i$ is an output of the entire update formula.
All outputs are killed in the first stage.
\item 
$c_i \le k_i, \forall i$.  A variable cannot be killed before it is created.
\item
$c_j \le c_i \le k_j$ if Variable $i$ directly depends on Variable $j$.  Variable $i$ is created in Stage $c_i$ using Variable $j$.  So Variable $j$ must be created at or before this stage, and cannot be killed before this stage.
\item $0 \le g_i \le 1, \forall i$, from the definition of $g_i$.
\item $g_i \ge 1$ if Variable $i$ directly depends on the neighbor grid points of its immediate input.  Again this is by definition of $g_i$. 
\item $g_i + c_i \ge g_j + c_j$ if Variable $i$ directly depends on Variable $j$.  Here Variable $i$ inherits the dependence of Variable $j$ to neighboring grid points, if Variables $i$ and $j$ are created in the same stage.  Otherwise, if $c_i \ge c_j + 1$, the inheritence is forgiven, and $g_i$ is allowed to be 0.
\item $g_i + c_i \ge g_j + c_j + 1$ if Variable $i$ directly depends on Variable $j$ at immediate neighbor grid points.  If $g_j$ is already 1, then Variable must be created at a later stage.
\end{enumerate}
This linear program has a size one more than three times the number of variables in the update formula.

We denote $V$ as the set of all variables, $V_S\subset V$ as all input variables of the update formula, and $V_T\subset V$ all output variables.
We also denote
\[\begin{split}
E &= \{(j,i) : i \textrm{ depends on }j\},\\
E_G &= \{(j,i) : i \textrm{ depends on } j \textrm{ at neighboring grid points}\} \subset E \;.
\end{split}\]
With these, the linear program can be written as
\begin{equation}
\begin{aligned}
& \min && \sum_i (k_i - c_i) w_i,               && \\
& \textrm{s.t.} & c_i &= 0,                     && \forall i\in V_S, \\
&               & k_i &= K,                     && \forall i\in V_T, \\
&               & c_i - k_i &\le 0,             && \forall i\in V, \\
&               &-g_i &\le 0,                   && \forall i\in V, \\
&               & g_i &\le 1,                   && \forall i\in V, \\
&               & c_j - c_i &\le 0,             && \forall (j,i) \in E, \\
&               & c_i - k_j &\le 0,             && \forall (j,i) \in E, \\
&               & g_j + c_j - g_i - c_i &\le 0, && \forall (j,i) \in E, \\
&               & g_i &= 1,                     && \forall (j,i) \in E_G,\\
&               & g_j + c_j - g_i - c_i &\le-1, && \forall (j,i) \in E_G,\\
\end{aligned}
\end{equation}

{\bf Theorem:} The solution of the linear program

\end{document}
