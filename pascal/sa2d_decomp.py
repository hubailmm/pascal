###############################################################################
#                                                                              #
#       sa2d_decomp.py copyright(c) Qiqi Wang 2015 (qiqi.wang@gmail.com)       #
#                                                                              #
################################################################################

import copy as copymodule
import builtins
import sys
import time
import pickle
import unittest
import operator
import collections

import numpy as np
import theano
import theano.tensor as T
import pulp

GLOBAL_MAX_STAGES = -128

# ============================================================================ #

def _is_like_sa_value(a):
    '''
    Check attributes of stencil array value
    '''
    if hasattr(a, 'owner'):
        return a.owner is None or hasattr(a.owner, 'access_neighbor')
    else:
        return False

def _is_like_sa(a):
    '''
    Check if object has a stencil array value
    '''
    return hasattr(a, 'value') and _is_like_sa_value(a.value)

def infer_context(a):
    '''
    Infer the appropriate math function, e.g., sin, to call on a
    Usage: infer_context(a).sin(a)
    '''
    if isinstance(a, np.ndarray):
        return np
    else:
        return a.__context__


# ============================================================================ #
#                                   Op class                                   #
# ============================================================================ #

class Op(object):
    '''
    Perform operations between values, and remember whether the operation
    accesses grid neighbors

    Op(operation, inputs)
        operation: a function that takes a list of inputs as arguments
        inputs: a list of stencil array
    '''
    def __init__(self, operation, inputs, access_neighbor=False,
                 dummy_func=np.ones, shape=None, name=None):
        self.operation = operation
        self.inputs = copymodule.copy(tuple(inputs))
        self.name = name

        produce_dummy = (lambda a:
            dummy_func(a.shape)
            if _is_like_sa_value(a)
            else a
            )
        dummy_inputs = tuple(map(produce_dummy, self.inputs))
        if shape is None:
            shape = operation(*dummy_inputs).shape

        self.access_neighbor = access_neighbor
        self.output = stencil_array_value(shape, self)

    def perform(self, input_objects):
        assert len(input_objects) == len(self.inputs)
        return self.operation(*input_objects)

    def __repr__(self):
        return 'Operator {0}'.format(self.name)


# ============================================================================ #
#                             stencil_array value                              #
# ============================================================================ #

class stencil_array_value(object):
    def __init__(self, shape=(), owner=None):
        self.shape = tuple(shape)
        self.owner = owner

    def __getstate__(self):
        return {'shape': self.shape, 'owner': self.owner}

    def __repr__(self):
        if self.owner:
            return 'Dependent value of shape {0} generated by {1}'.format(
                    self.shape, self.owner)
        else:
            return 'Independent value of shape {0}'.format(self.shape)

    # --------------------------- properties ------------------------------ #

    @property
    def ndim(self):
        return len(self.shape)

    @property
    def size(self):
        return int(np.prod(self.shape))

    def __len__(self):
        return 1 if not self.shape else self.shape[0]


# ============================================================================ #
#                          stencil array variable                              #
# ============================================================================ #

class stencil_array(object):

    __context__ = sys.modules[__name__]

    def __init__(self, init=()):
        if _is_like_sa_value(init):
            self.value = init
        else:
            shape = init
            self.value = stencil_array_value(shape)

    def __repr__(self):
        return 'Variable holding {0}'.format(self.value)

    # --------------------------- properties ------------------------------ #

    @property
    def shape(self):
        return self.value.shape

    @property
    def ndim(self):
        return self.value.ndim

    @property
    def size(self):
        return self.value.size

    def __len__(self):
        return len(self.value)

    # --------------------------- operations ------------------------------ #

    # asks ndarray to use the __rops__ defined in this class
    __array_priority__ = 3000

    def __add__(self, a):
        if hasattr(a, '__array_priority__') and \
                a.__array_priority__ > self.__array_priority__:
            return a.__add__(self)
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.add, (self.value, a), name='add')
        return stencil_array(owner.output)

    def __radd__(self, a):
        return self.__add__(a)

    def __sub__(self, a):
        if hasattr(a, '__array_priority__') and \
                a.__array_priority__ > self.__array_priority__:
            return a.__rsub__(self)
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.sub, (self.value, a), name='sub')
        return stencil_array(owner.output)

    def __rsub__(self, a):
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.sub, (a, self.value), name='sub')
        return stencil_array(owner.output)

    def __mul__(self, a):
        if hasattr(a, '__array_priority__') and \
                a.__array_priority__ > self.__array_priority__:
            return a.__rmul__(self)
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.mul, (self.value, a), name='mul')
        return stencil_array(owner.output)

    def __rmul__(self, a):
        return self.__mul__(a)

    def __truediv__(self, a):
        if hasattr(a, '__array_priority__') and \
                a.__array_priority__ > self.__array_priority__:
            return a.__rtruediv__(self)
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.truediv, (self.value, a), name='div')
        return stencil_array(owner.output)

    def __rtruediv__(self, a):
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.truediv, (a, self.value), name='div')
        return stencil_array(owner.output)

    def __pow__(self, a):
        if hasattr(a, '__array_priority__') and \
                a.__array_priority__ > self.__array_priority__:
            return a.__rpow__(self)
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.pow, (self.value, a), name='pow')
        return stencil_array(owner.output)

    def __rpow__(self, a):
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.pow, (a, self.value), name='pow')
        return stencil_array(owner.output)

    def __neg__(self):
        owner = Op(operator.neg, (self.value,), name='neg')
        return stencil_array(owner.output)

    # ------------------------- math functions ---------------------------- #

    def sum(self, axis=None):
        return sum(self, axis)

    def mean(self, axis=None):
        return mean(self, axis)

    # ------------------------- transformations --------------------------- #

    @property
    def T(self):
        return transpose(self)

    def transpose(self, axes=None):
        return transpose(self, axes)

    def reshape(self, shape):
        return reshape(self, shape)

    def copy(self):
        return copy(self)

    # ------------------------ neighbor access -------------------------- #
    @staticmethod
    class dummy_func(object):
        def __init__(self, shape):
            self.shape = shape
            self.x_p = self
            self.x_m = self
            self.y_p = self
            self.y_m = self

    @property
    def x_p(self):
        owner = Op(lambda x: x.x_p,
                   (self.value,),
                   access_neighbor=True,
                   dummy_func=self.dummy_func)
        return stencil_array(owner.output)

    @property
    def x_m(self):
        owner = Op(lambda x: x.x_m,
                   (self.value,),
                   access_neighbor=True,
                   dummy_func=self.dummy_func)
        return stencil_array(owner.output)

    @property
    def y_p(self):
        owner = Op(lambda x: x.y_p,
                   (self.value,),
                   access_neighbor=True,
                   dummy_func=self.dummy_func)
        return stencil_array(owner.output)

    @property
    def y_m(self):
        owner = Op(lambda x: x.y_m,
                   (self.value,),
                   access_neighbor=True,
                   dummy_func=self.dummy_func)
        return stencil_array(owner.output)

    # ---------------------------- indexing ------------------------------- #

    def __getitem__(self, ind):
        ind = copymodule.copy(ind)
        op = lambda x: x[ind]
        owner = Op(op, (self.value,), name='getitem[{0}]'.format(ind))
        return stencil_array(owner.output)

    def __setitem__(self, ind, a):
        ind = copymodule.copy(ind)
        def op(x, a):
            x = copymodule.copy(x)
            x[ind] = a
            return x

        a = a.value if _is_like_sa(a) else a
        owner = Op(op, (self.value, a), shape=self.shape,
                   name='setitem[{0}]'.format(ind))
        assert self.shape == owner.output.shape
        self.value = owner.output


# ============================================================================ #
#                             data transformations                             #
# ============================================================================ #

def transpose(x, axes=None):
    assert _is_like_sa(x)
    axes = copymodule.copy(axes)
    op = lambda x: x.transpose(axes)
    owner = Op(op, (x.value,), name='transpose')
    return stencil_array(owner.output)

def reshape(x, shape):
    assert _is_like_sa(x)
    shape = copymodule.copy(shape)
    op = lambda x: x.reshape(shape)
    owner = Op(op, (x.value,), name='reshape')
    return stencil_array(owner.output)

def roll(x, shift, axis=None):
    assert _is_like_sa(x)
    shift, axis = copymodule.copy(shift), copymodule.copy(axis)
    op = lambda x: infer_context(x).roll(x, shift, axis)
    owner = Op(op, (x.value,), name='reshape')
    return stencil_array(owner.output)

def copy(x):
    assert _is_like_sa(x)
    return stencil_array(x.value)


# ============================================================================ #
#                            mathematical functions                            #
# ============================================================================ #

def sin(a):
    assert _is_like_sa(a)
    op = lambda x: infer_context(x).sin(x)
    owner = Op(op, (a.value,), name='sin')
    return stencil_array(owner.output)

def cos(a):
    assert _is_like_sa(a)
    op = lambda x: infer_context(x).cos(x)
    owner = Op(op, (a.value,), name='cos')
    return stencil_array(owner.output)

def exp(a):
    assert _is_like_sa(a)
    op = lambda x: infer_context(x).exp(x)
    owner = Op(op, (a.value,), name='exp')
    return stencil_array(owner.output)

def sum(a, axis=None):
    assert _is_like_sa(a)
    axis = copymodule.copy(axis)
    op = lambda x: infer_context(x).sum(x, axis)
    owner = Op(op, (a.value,), name='sum')
    return stencil_array(owner.output)

def mean(a, axis=None):
    assert _is_like_sa(a)
    axis = copymodule.copy(axis)
    op = lambda x: infer_context(x).mean(x, axis)
    owner = Op(op, (a.value,), name='mean')
    return stencil_array(owner.output)

# ============================================================================ #
#                             built-in source array                            #
# ============================================================================ #

G_ZERO = stencil_array_value()

def ones(shape=()):
    return stencil_array(G_ZERO) + np.ones(shape)

def zeros(shape=()):
    return stencil_array(G_ZERO) + np.zeros(shape)


# ============================================================================ #
#                                decomposition                                 #
# ============================================================================ #

_LP = collections.namedtuple('LP', 'c, bounds, A_eq, A_le, b_eq, b_le')
_LPRes = collections.namedtuple('LPRes', 'x, obj, status')

# ---------------------------------------------------------------------------- #

def _build_linear_program(all_values, upstream_values, downstream_values):
    '''
    solution: [c, k, g, K]
    c: length n array of integers, the stage in which a value is created;
    k: length n array of integers, the stage in which a value is killed;
    g: length n array of 0 and 1's, bareness of array,
       1 indicating it is bare, i.e, has no neighbors upon creation;
       0 indicating it has one layer of neighbor upon creation.
    '''
    def add_eq(A_c, A_k, A_g, A_K, b):
        A_eq.append(np.hstack([A_c, A_k, A_g, A_K]))
        b_eq.append(b)

    def add_le(A_c, A_k, A_g, A_K, b):
        A_le.append(np.hstack([A_c, A_k, A_g, A_K]))
        b_le.append(b)

    n = len(all_values)
    A_eq, A_le, b_eq, b_le = [], [], [], []
    # build bounds
    non_negative = (0, GLOBAL_MAX_STAGES)
    bounds = [non_negative] * (2 * n) + [(0, 1)] * n + [non_negative]
    # build constraints
    z = np.zeros(n)
    e = np.eye(n)
    for a in upstream_values:
        i = a._valueId
        # an input value is born at Stage 0
        add_eq(e[i], z, z, 0, 0)
    for a in downstream_values:
        i = a._valueId
        # an output value is killed at Stage K (last stage)
        add_eq(z, e[i], z, -1, 0)
    for a in all_values:
        i = a._valueId
        # a value cannot be killed before it is born
        add_le(e[i], -e[i], z, 0, 0)
        if a.owner:
            for b in a.owner.inputs:
                if _is_like_sa_value(b):
                    assert b in all_values
                    j = b._valueId
                    # a child cannot be born before its parent is born
                    add_le(e[j] - e[i], z, z, 0, 0)
                    # a child cannot be born after its parent is killed
                    add_le(e[i], -e[j], z, 0, 0)
                    if a.owner.access_neighbor:
                        # a bare parent must wait to next stage
                        # to produce any child through neibhor access
                        add_le(e[j] - e[i], z, e[j] - e[i], 0, -1)
                    else:
                        # a bare parent produces bare children
                        # during its creating stage
                        add_le(e[j] - e[i], z, e[j] - e[i], 0, 0)
            if a.owner.access_neighbor:
                # a child born through neighbor access is bare
                add_eq(z, z, e[i], 0, 1)
    w = np.array([a.size for a in all_values])
    c = np.hstack([-w, w, z, 0])
    return _LP(np.array(c, float), np.array(bounds, float),
               np.array(A_eq, float), np.array(A_le, float),
               np.array(b_eq, float), np.array(b_le, float))

# ---------------------------------------------------------------------------- #

def _solve_linear_program_glpk(linear_program, verbose):
    c, bounds, A_eq, A_le, b_eq, b_le = linear_program
    lp = pulp.LpProblem("Decomposition", pulp.LpMinimize)
    # add the variables
    x = []
    for i, (l, u) in enumerate(bounds):
        if u == GLOBAL_MAX_STAGES:
            x.append(pulp.LpVariable('x'+str(i), l, None))
        else:
            x.append(pulp.LpVariable('x'+str(i), l, u))
    # specify the objective
    assert len(x) == len(c)
    lp += builtins.sum(c[i] * x[i] for i in range(len(x)))
    # add the constraints
    for i in range(b_le.size):
        j, = A_le[i].nonzero()
        lp += builtins.sum(A_le[i, jj] * x[jj] for jj in j) <= b_le[i]
    for i in range(b_eq.size):
        j, = A_eq[i].nonzero()
        lp += builtins.sum(A_eq[i, jj] * x[jj] for jj in j) == b_eq[i]
    # solve with GLPK
    s = pulp.GLPK(mip=0, msg=int(verbose > 1))
    s.actualSolve(lp)
    # extract solution
    x = [pulp.value(xi) for xi in x]
    assert all([abs(xi - round(xi)) < 1E-12 for xi in x]), \
           'Linear Program Finished with non-integer results'
    x = np.array(np.around(x), int)
    objective = int(round(pulp.value(lp.objective)))
    status = pulp.LpStatus[lp.status]
    return _LPRes(x, objective, status)

# ---------------------------------------------------------------------------- #

def _solve_linear_program(linear_program, verbose):
    if verbose:
        lpSize = (len(linear_program.c),
                  len(linear_program.b_eq) + len(linear_program.b_le))
        print('\nDecomposing update formula')
        print('\tsolving {0}x{1} linear program'.format(*lpSize))
        sys.stdout.flush()
        t0 = time.time()
    res = _solve_linear_program_glpk(linear_program, verbose)
    if verbose:
        print('Decomposed into {0} atomic stages'.format(res.x[-1] + 1))
        print('\tobjective function = {0}'.format(res.obj))
        print('\tstatus: ' + res.status)
        print('\ttime: {0:f}'.format(time.time() - t0))
        sys.stdout.flush()
    return res

# ---------------------------------------------------------------------------- #

def _assign_lp_results_to_values(lp_result, values):
    c, k, g = lp_result.x[:-1].reshape([3,-1])
    assert c.size == len(values)
    assert g.max() <= 1
    for i, a in enumerate(values):
        a = values[i]
        a.create_stage = int(round(c[i]))
        a.kill_stage = int(round(k[i]))
        a.has_neighbor = (round(g[i]) == 0)
    num_stages = int(lp_result.x[-1]) + 1
    return num_stages

# ---------------------------------------------------------------------------- #

def decompose(upstream_values, downstream_values, verbose=True):
    values, triburary_values = discover_values(
            upstream_values, downstream_values)
    all_values = (list(values) +
                  list(triburary_values) +
                  list(upstream_values))
    for i, v in enumerate(all_values):
        v._valueId = i
    lp = _build_linear_program(all_values, upstream_values, downstream_values)
    lp_res = _solve_linear_program(lp, verbose)
    num_stages = _assign_lp_results_to_values(lp_res, all_values)
    for v in all_values:
        del v._valueId
    # create each atomic stage from its upstream and downstream values
    stages = []
    stage_upstream = list(upstream_values)
    for k in range(1, num_stages):
        stage_downstream = [v for v in all_values
                            if v.create_stage < k and v.kill_stage >= k]
        stages.append(AtomicStage(stage_upstream, stage_downstream))
        stage_upstream = stage_downstream
    stage_downstream = list(downstream_values)
    stages.append(AtomicStage(stage_upstream, stage_downstream))
    # stack inter-stage values for more efficient halo exchange
    for k in range(num_stages - 1):
        stages[k] = stack_downstream(stages[k])
    for k in range(1, num_stages):
        stages[k] = stack_upstream(stages[k])
    return stages

# ---------------------------------------------------------------------------- #

def decompose_function(func, inputs, verbose=True):
    if not isinstance(inputs, (tuple, list)):
        inputs = (inputs,)

    def _tidy_input(inp):
        if hasattr(inp, 'shape'):
            return stencil_array(inp.shape)
        else:
            return stencil_array(np.array(inp).shape)

    inputs = tuple(map(_tidy_input, inputs))
    upstream_values = tuple(inp.value for inp in inputs)
    outputs = func(*inputs)
    if not isinstance(outputs, tuple):
        outputs = (outputs,)
    downstream_values = tuple(out.value for out in outputs)
    return decompose(upstream_values, downstream_values, verbose)


# ============================================================================ #
#                                atomic stage                                  #
# ============================================================================ #

def discover_values(upstream_values, downstream_values):
    discovered_values = []
    discovered_triburary_values = []
    def discover_values_from(v):
        if not hasattr(v, 'owner'):
            return
        if v in upstream_values:
            return
        if v.owner is None:
            if v not in discovered_triburary_values:
                discovered_triburary_values.append(v)
        elif v not in discovered_values:
            discovered_values.append(v)
            for v_inp in v.owner.inputs:
                discover_values_from(v_inp)
    for v in downstream_values:
        discover_values_from(v)
    return discovered_values, discovered_triburary_values

def sort_values(sorted_values, unsorted_values):
    def is_computable(v):
        return (not _is_like_sa_value(v) or
                v in sorted_values or
                v.owner is None)
    while len(unsorted_values):
        removed_any = False
        for v in unsorted_values:
            if all([is_computable(v_inp) for v_inp in v.owner.inputs]):
                unsorted_values.remove(v)
                sorted_values.append(v)
                removed_any = True
        if not removed_any:
            return

class AtomicStage(object):
    def __init__(self, upstream_values, downstream_values):
        sorted_values = copymodule.copy(upstream_values)
        unsorted_values, self.triburary_values = discover_values(
                upstream_values, downstream_values)
        sort_values(sorted_values, unsorted_values)
        assert unsorted_values == []
        self.upstream_values = sorted_values[:len(upstream_values)]
        self.sorted_values = sorted_values[len(upstream_values):]
        self.downstream_values = copymodule.copy(downstream_values)

    def __call__(self, upstream_values, triburary_values=[]):
        upstream_values = list(upstream_values)
        triburary_values = list(triburary_values)
        # _tmp attributes are assigned to inputs
        values = self.upstream_values + self.triburary_values
        tmp_values = upstream_values + triburary_values
        assert len(values) == len(tmp_values)
        for v, v_tmp in zip(values, tmp_values):
            assert not hasattr(v, '_tmp')
            v._tmp = v_tmp
        # _tmp attributes are computed to each value
        _tmp = lambda v : v._tmp if _is_like_sa_value(v) else v
        for v in self.sorted_values:
            assert not hasattr(v, '_tmp')
            inputs_tmp = [_tmp(v_inp) for v_inp in v.owner.inputs]
            v._tmp = v.owner.perform(inputs_tmp)
        # _tmp attributes are extracted from outputs then deleted from all
        downstream_values = tuple(v._tmp for v in self.downstream_values)
        values += self.sorted_values
        for v in values:
            del v._tmp
        return downstream_values

def stack_upstream(stage):
    upstream_total_size = builtins.sum(
            [v.size for v in stage.upstream_values])
    stacked_upstream_array = stencil_array((upstream_total_size,))
    stacked_upstream_value = stacked_upstream_array.value
    # split stacked upstream array
    upstream_arrays = []
    i_ptr = 0
    for v in stage.upstream_values:
        array_slice = stacked_upstream_array[i_ptr:i_ptr+v.size]
        upstream_arrays.append(array_slice.reshape(v.shape))
        i_ptr += v.size
    # construct stage based on stacked upstream values
    triburary_arrays = [stencil_array(v) for v in stage.triburary_values]
    downstream_arrays = stage(upstream_arrays, triburary_arrays)
    downstream_values = [a.value for a in downstream_arrays]
    return AtomicStage([stacked_upstream_value], downstream_values)

def stack_downstream(stage):
    downstream_total_size = builtins.sum(
            [v.size for v in stage.downstream_values])
    stacked_downstream_array = zeros((downstream_total_size,))
    i_ptr = 0
    for v in stage.downstream_values:
        downstream_array_slice = stencil_array(v).reshape((v.size,))
        stacked_downstream_array[i_ptr:i_ptr+v.size] = downstream_array_slice
        i_ptr += v.size
    return AtomicStage(stage.upstream_values, [stacked_downstream_array.value])

class Stage(object):
    def __init__(self, values, globalInputs, globalOutputs, k, K):
        assert k >= 0 and k < K
        self.k = k

        isIn = lambda a: a.create_stage < k and a.kill_stage >= k
        isOut = lambda a: a.create_stage <= k and a.kill_stage > k

        self.inputs = (tuple(filter(isIn, values)) if k > 0
                       else globalInputs)
        self.outputs = (tuple(filter(isOut, values)) if k < K - 1
                        else globalOutputs)

        isKSource = lambda a: (a.create_stage == k and
                               a.owner is None and
                               a not in globalInputs)
        self.sourceValues = tuple(filter(isKSource, values))

        isKVar = lambda a: (a.create_stage == k and
                            a.owner is not None)
        self._order_values(list(filter(isKVar, values)))

    def _order_values(self, stage_k_values):
        self.orderedValues = []
        while stage_k_values:
            numRemoved = 0
            for a in stage_k_values:
                isReady = lambda b: (b in self.orderedValues or
                                     b in self.inputs or
                                     b in self.sourceValues)
                a_inputs = filter(_is_like_sa_value, a.owner.inputs)
                if all([isReady(b) for b in a_inputs]):
                    self.orderedValues.append(a)
                    stage_k_values.remove(a)
                    numRemoved += 1
            assert numRemoved > 0

    # --------------------------------------------------------------------- #

    def _has_nbr(self, out):
        return out.create_stage < self.k or out.has_neighbor

    @property
    def output_size_no_nbr(self):
        return builtins.sum(
                out.size for out in self.outputs if not self._has_nbr(out))
    @property
    def output_size_has_nbr(self):
        return builtins.sum(
                out.size for out in self.outputs if self._has_nbr(out))

    def _is_old_nbr(self, inp):
        return (inp.create_stage < self.k - 1 or inp.has_neighbor)

    def unstack_input(self, input_new_nbr, input_old_nbr):
        input_objects = [None] * len(self.inputs)

        ptr = 0
        for i, inp in enumerate(self.inputs):
            if not self._is_old_nbr(inp):
                inp_obj = input_new_nbr[ptr : ptr + inp.size]
                ptr += inp.size
                input_objects[i] = inp_obj.reshape(inp.shape)
        assert ptr == input_new_nbr.size

        ptr = 0
        for i, inp in enumerate(self.inputs):
            if self._is_old_nbr(inp):
                inp_obj = input_old_nbr[ptr : ptr + inp.size]
                ptr += inp.size
                input_objects[i] = inp_obj.reshape(inp.shape)
        assert ptr == input_old_nbr.size

        return input_objects

    def stack_output(self, output_objects):
        context = infer_context(output_objects[0])

        output_no_nbr = context.zeros(self.output_size_no_nbr)
        ptr = 0
        for out, out_obj in zip(self.outputs, output_objects):
            assert out.shape == out_obj.shape
            if not self._has_nbr(out):
                out_obj = out_obj.reshape(out.size)
                output_no_nbr[ptr : ptr + out.size] = out_obj
                ptr += out.size
        assert output_no_nbr.size == ptr

        if self.output_size_has_nbr == 0:
            return output_no_nbr

        output_has_nbr = context.zeros(self.output_size_has_nbr)
        ptr = 0
        for out, out_obj in zip(self.outputs, output_objects):
            assert out.shape == out_obj.shape
            if self._has_nbr(out):
                out_obj = out_obj.reshape(out.size)
                output_has_nbr[ptr : ptr + out.size] = out_obj
                ptr += out.size
        assert output_has_nbr.size == ptr

        return output_no_nbr, output_has_nbr

    def __call__(self, input_objects, source_objects=()):
        assert len(input_objects) == len(self.inputs)
        for a, a_obj in zip(self.inputs, input_objects):
            assert not hasattr(a, '_obj')
            a._obj = a_obj

        for a, a_obj in zip(self.sourceValues, source_objects):
            assert not hasattr(a, '_obj')
            a._obj = a_obj

        for a in self.orderedValues:
            assert not hasattr(a, '_obj')
            a_inputs = filter(_is_like_sa_value, a.owner.inputs)
            assert all([hasattr(b, '_obj') for b in a_inputs])
            extract_obj = lambda b: b._obj if _is_like_sa_value(b) else b
            a_input_objects = tuple(extract_obj(b) for b in a.owner.inputs)
            a._obj = a.owner.perform(a_input_objects)

        assert all([hasattr(a, '_obj') for a in self.outputs])
        output_objects = tuple(a._obj for a in self.outputs)

        for a in self.inputs:
            del a._obj
        for a in self.sourceValues:
            del a._obj
        for a in self.orderedValues:
            del a._obj

        return output_objects

################################################################################
################################################################################
################################################################################
