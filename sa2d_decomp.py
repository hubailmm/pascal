# ============================================================================ #
#                                                                              #
#       sa2d_decomp.py copyright(c) Qiqi Wang 2015 (qiqi.wang@gmail.com)       #
#                                                                              #
# ============================================================================ #

from __future__ import division, print_function

try:
    import builtins
except:
    import __builtin__ as builtins
import copy as copymodule
import sys
import pickle
import unittest
import operator
import collections
import numpy as np
import theano
import theano.tensor as T
import scipy.io
import pulp

GLOBAL_MAX_STAGES = -128

# ============================================================================ #

def _is_like_sa_value(a):
    '''
    Check attributes of stencil array value
    '''
    if hasattr(a, 'owner'):
        return a.owner is None or hasattr(a.owner, 'access_neighbor')
    else:
        return False

def _is_like_sa(a):
    '''
    Check if object has a stencil array value
    '''
    return hasattr(a, 'value') and _is_like_sa_value(a.value)

def _infer_context(a):
    '''
    Infer the appropriate math function, e.g., sin, to call on a
    Usage: _infer_context(a).sin(a)
    '''
    if isinstance(a, np.ndarray):
        return np
    else:
        return a.__context__


# ============================================================================ #
#                                   Op class                                   #
# ============================================================================ #

class Op(object):
    '''
    Perform operations between values, and remember whether the operation
    accesses grid neighbors

    Op(operation, inputs)
        operation: a function that takes a list of inputs as arguments
        inputs: a list of stencil array
    '''
    def __init__(self, operation, inputs, access_neighbor=False,
                 dummy_func=np.ones, shape=None, name=None):
        self.operation = operation
        self.inputs = copymodule.copy(tuple(inputs))
        self.name = name

        produce_dummy = lambda a : \
            dummy_func(a.shape) if _is_like_sa_value(a) else a
        dummy_inputs = tuple(map(produce_dummy, self.inputs))
        if shape is None:
            shape = operation(*dummy_inputs).shape

        self.access_neighbor = access_neighbor
        self.output = stencil_array_value(shape, self)

    def perform(self, input_objects):
        assert len(input_objects) == len(self.inputs)
        return self.operation(*input_objects)

    def __repr__(self):
        return 'Operator {0}'.format(self.name)


# ============================================================================ #
#                             stencil_array value                              #
# ============================================================================ #

class stencil_array_value(object):
    def __init__(self, shape=(), owner=None):
        self.shape = tuple(shape)
        self.owner = owner

    def __repr__(self):
        if self.owner:
            return 'Dependent value of shape {0} generated by {1}'.format(
                    self.shape, self.owner)
        else:
            return 'Independent value of shape {0}'.format(self.shape)

    # --------------------------- properties ------------------------------ #

    @property
    def ndim(self):
        return len(self.shape)

    @property
    def size(self):
        return int(np.prod(self.shape))

    def __len__(self):
        return 1 if not self.shape else self.shape[0]


# ============================================================================ #
#                          stencil array variable                              #
# ============================================================================ #

class stencil_array(object):

    __context__ = sys.modules[__name__]

    def __init__(self, init=()):
        if _is_like_sa_value(init):
            self.value = init
        else:
            shape = init
            self.value = stencil_array_value(shape)

    def __repr__(self):
        return 'Variable holding {0}'.format(self.value)

    # --------------------------- properties ------------------------------ #

    @property
    def shape(self):
        return self.value.shape

    @property
    def ndim(self):
        return self.value.ndim

    @property
    def size(self):
        return self.value.size

    def __len__(self):
        return len(self.value)

    # --------------------------- operations ------------------------------ #

    # asks ndarray to use the __rops__ defined in this class
    __array_priority__ = 3000

    def __add__(self, a):
        if hasattr(a, '__array_priority__') and \
                a.__array_priority__ > self.__array_priority__:
            return a.__add__(self)
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.add, (self.value, a), name='add')
        return stencil_array(owner.output)

    def __radd__(self, a):
        return self.__add__(a)

    def __sub__(self, a):
        if hasattr(a, '__array_priority__') and \
                a.__array_priority__ > self.__array_priority__:
            return a.__rsub__(self)
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.sub, (self.value, a), name='sub')
        return stencil_array(owner.output)

    def __rsub__(self, a):
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.sub, (a, self.value), name='sub')
        return stencil_array(owner.output)

    def __mul__(self, a):
        if hasattr(a, '__array_priority__') and \
                a.__array_priority__ > self.__array_priority__:
            return a.__rmul__(self)
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.mul, (self.value, a), name='mul')
        return stencil_array(owner.output)

    def __rmul__(self, a):
        return self.__mul__(a)

    def __truediv__(self, a):
        if hasattr(a, '__array_priority__') and \
                a.__array_priority__ > self.__array_priority__:
            return a.__rtruediv__(self)
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.truediv, (self.value, a), name='div')
        return stencil_array(owner.output)

    def __rtruediv__(self, a):
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.truediv, (a, self.value), name='div')
        return stencil_array(owner.output)

    def __pow__(self, a):
        if hasattr(a, '__array_priority__') and \
                a.__array_priority__ > self.__array_priority__:
            return a.__rpow__(self)
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.pow, (self.value, a), name='pow')
        return stencil_array(owner.output)

    def __rpow__(self, a):
        a = a.value if _is_like_sa(a) else a
        owner = Op(operator.pow, (a, self.value), name='pow')
        return stencil_array(owner.output)

    def __neg__(self):
        owner = Op(operator.neg, (self.value,), name='neg')
        return stencil_array(owner.output)

    # ------------------------- math functions ---------------------------- #

    def sum(self, axis=None):
        return sum(self, axis)

    def mean(self, axis=None):
        return mean(self, axis)

    # ------------------------- transformations --------------------------- #

    @property
    def T(self):
        return transpose(self)

    def transpose(self, axes=None):
        return transpose(self, axes)

    def reshape(self, shape):
        return reshape(self, shape)

    def copy(self):
        return copy(self)

    # ------------------------ neighbor access -------------------------- #
    @staticmethod
    class dummy_func(object):
        def __init__(self, shape):
            self.shape = shape
            self.x_p = self
            self.x_m = self
            self.y_p = self
            self.y_m = self

    @property
    def x_p(self):
        owner = Op(lambda x : x.x_p, (self.value,), access_neighbor=True,
                   dummy_func=self.dummy_func)
        return stencil_array(owner.output)

    @property
    def x_m(self):
        owner = Op(lambda x : x.x_m, (self.value,), access_neighbor=True,
                   dummy_func=self.dummy_func)
        return stencil_array(owner.output)

    @property
    def y_p(self):
        owner = Op(lambda x : x.y_p, (self.value,), access_neighbor=True,
                   dummy_func=self.dummy_func)
        return stencil_array(owner.output)

    @property
    def y_m(self):
        owner = Op(lambda x : x.y_m, (self.value,), access_neighbor=True,
                   dummy_func=self.dummy_func)
        return stencil_array(owner.output)

    # ---------------------------- indexing ------------------------------- #

    def __getitem__(self, ind):
        ind = copymodule.copy(ind)
        op = lambda x : x[ind]
        owner = Op(op, (self.value,), name='getitem[{0}]'.format(ind))
        return stencil_array(owner.output)

    def __setitem__(self, ind, a):
        ind = copymodule.copy(ind)
        def op(x, a):
            x = copymodule.copy(x)
            x[ind] = a
            return x

        a = a.value if _is_like_sa(a) else a
        owner = Op(op, (self.value, a), shape=self.shape,
                   name='setitem[{0}]'.format(ind))
        assert self.shape == owner.output.shape
        self.value = owner.output


# ============================================================================ #
#                             data transformations                             #
# ============================================================================ #

def transpose(x, axes=None):
    assert _is_like_sa(x)
    axes = copymodule.copy(axes)
    op = lambda x : x.transpose(axes)
    owner = Op(op, (x.value,), name='transpose')
    return stencil_array(owner.output)

def reshape(x, shape):
    assert _is_like_sa(x)
    shape = copymodule.copy(shape)
    op = lambda x : x.reshape(shape)
    owner = Op(op, (x.value,), name='reshape')
    return stencil_array(owner.output)

def roll(x, shift, axis=None):
    assert _is_like_sa(x)
    shift, axis = copymodule.copy(shift), copymodule.copy(axis)
    op = lambda x : _infer_context(x).roll(x, shift, axis)
    owner = Op(op, (x.value,), name='reshape')
    return stencil_array(owner.output)

def copy(x):
    assert _is_like_sa(x)
    return stencil_array(x.value)


# ============================================================================ #
#                            mathematical functions                            #
# ============================================================================ #

def sin(a):
    assert _is_like_sa(a)
    owner = Op(lambda x : _infer_context(x).sin(x), (a.value,), name='sin')
    return stencil_array(owner.output)

def cos(a):
    assert _is_like_sa(a)
    owner = Op(lambda x : _infer_context(x).cos(x), (a.value,), name='cos')
    return stencil_array(owner.output)

def exp(a):
    assert _is_like_sa(a)
    owner = Op(lambda x : _infer_context(x).exp(x), (a.value,), name='exp')
    return stencil_array(owner.output)

def sum(a, axis=None):
    assert _is_like_sa(a)
    axis = copymodule.copy(axis)
    op = lambda x : _infer_context(x).sum(x, axis)
    owner = Op(op, (a.value,), name='sum')
    return stencil_array(owner.output)

def mean(a, axis=None):
    assert _is_like_sa(a)
    axis = copymodule.copy(axis)
    op = lambda x : _infer_context(x).mean(x, axis)
    owner = Op(op, (a.value,), name='mean')
    return stencil_array(owner.output)

# ============================================================================ #
#                             built-in source array                            #
# ============================================================================ #

G_ZERO = stencil_array_value()

def ones(shape=()):
    return stencil_array(G_ZERO) + np.ones(shape)

def zeros(shape=()):
    return stencil_array(G_ZERO) + np.zeros(shape)


# ============================================================================ #
#                                decomposition                                 #
# ============================================================================ #

class decompose(object):
    '''
    '''
    # TODO: Add comments

    LP = collections.namedtuple('LP', 'c, bounds, A_eq, A_le, b_eq, b_le')
    LPRes = collections.namedtuple('LPRes', 'x, obj, status')

    def _build_computational_graph(self, func, inputs):
        if not isinstance(inputs, tuple):
            inputs = (inputs,)

        def _tidy_input(inp):
            if hasattr(inp, 'shape'):
                return stencil_array(inp.shape)
            else:
                return stencil_array(np.array(inp).shape)

        inputs = tuple(map(_tidy_input, inputs))
        self.inputs = tuple(inp.value for inp in inputs)

        outputs = func(*inputs)
        if not isinstance(outputs, tuple):
            outputs = (outputs,)
        self.outputs = tuple(out.value for out in outputs)


    # --------------------------------------------------------------------- #

    def _assign_id_to_values(self):
        self.values = []
        def set_value_id(a):
            if _is_like_sa_value(a) and a not in self.values:
                a._valueId = len(self.values)
                self.values.append(a)
                if a.owner:
                    for inp in a.owner.inputs:
                        set_value_id(inp)
        for out in self.outputs:
            set_value_id(out)

        self.values = list(self.values)
        assert all([a._valueId < len(self.values) for a in self.values])

    # --------------------------------------------------------------------- #

    def _build_linear_program(self):
        '''
        solution: [c, k, g, K]
        c: length n array of integers, the stage in which a value is created;
        k: length n array of integers, the stage in which a value is killed;
        g: length n array of 0 and 1's, bareness of array,
           1 indicating it is bare, i.e, has no neighbors upon creation;
           0 indicating it has one layer of neighbor upon creation.
        '''
        A_eq, A_le, b_eq, b_le = [], [], [], []

        def add_eq(A_c, A_k, A_g, A_K, b):
            A_eq.append(np.hstack([A_c, A_k, A_g, A_K]))
            b_eq.append(b)

        def add_le(A_c, A_k, A_g, A_K, b):
            A_le.append(np.hstack([A_c, A_k, A_g, A_K]))
            b_le.append(b)

        n = len(self.values)

        # build bounds
        non_negative = (0, GLOBAL_MAX_STAGES)
        bounds = [non_negative] * (2 * n) + [(0, 1)] * n + [non_negative]

        # build constraints
        z = np.zeros(n)
        e = np.eye(n)

        for a in self.inputs:
            i = a._valueId
            # an input value is born at Stage 0
            add_eq(e[i], z, z, 0, 0)

        for a in self.outputs:
            i = a._valueId
            # an output value is killed at Stage K (last stage)
            add_eq(z, e[i], z, -1, 0)

        for a in self.values:
            i = a._valueId
            # a value cannot be killed before it is born
            add_le(e[i], -e[i], z, 0, 0)

            if a.owner:
                for b in a.owner.inputs:
                    if _is_like_sa_value(b):
                        assert b in self.values
                        j = b._valueId
                        # a child cannot be born before its parent is born
                        add_le(e[j] - e[i], z, z, 0, 0)
                        # a child cannot be born after its parent is killed
                        add_le(e[i], -e[j], z, 0, 0)
                        if a.owner.access_neighbor:
                            # a bare parent must wait to next stage
                            # to produce any child through neibhor access
                            add_le(e[j] - e[i], z, e[j] - e[i], 0, -1)
                        else:
                            # a bare parent produces bare children
                            # during its creating stage
                            add_le(e[j] - e[i], z, e[j] - e[i], 0, 0)
                if a.owner.access_neighbor:
                    # a child born through neighbor access is bare
                    add_eq(z, z, e[i], 0, 1)

        w = np.array([a.size for a in self.values])
        c = np.hstack([-w, w, z, 0])

        self._linear_program = self.LP(
                np.array(c, float), np.array(bounds, float),
                np.array(A_eq, float), np.array(A_le, float),
                np.array(b_eq, float), np.array(b_le, float))

    # --------------------------------------------------------------------- #

    def _solve_linear_program_glpk(self, verbose):
        c, bounds, A_eq, A_le, b_eq, b_le = self._linear_program

        lp = pulp.LpProblem("Decomposition", pulp.LpMinimize)

        x = []
        for i, (l, u) in enumerate(bounds):
            if u == GLOBAL_MAX_STAGES:
                x.append(pulp.LpVariable('x'+str(i), l, None))
            else:
                x.append(pulp.LpVariable('x'+str(i), l, u))

        assert len(x) == len(c)
        lp += builtins.sum(c[i] * x[i] for i in range(len(x)))

        for i in range(b_le.size):
            j, = A_le[i].nonzero()
            lp += builtins.sum(A_le[i, jj] * x[jj] for jj in j) <= b_le[i]
        for i in range(b_eq.size):
            j, = A_eq[i].nonzero()
            lp += builtins.sum(A_eq[i, jj] * x[jj] for jj in j) == b_eq[i]

        s = pulp.GLPK(mip=0, msg=int(verbose))
        s.actualSolve(lp)

        x = [pulp.value(xi) for xi in x]
        assert all([abs(xi - round(xi)) < 1E-12 for xi in x]), \
               'Linear Program Finished with non-integer results'

        x = np.array(np.around(x), int)
        objective = int(round(pulp.value(lp.objective)))
        status = pulp.LpStatus[lp.status]

        self._linear_program_result = self.LPRes(x, objective, status)

    # --------------------------------------------------------------------- #

    def _solve_linear_program(self, verbose, save_mat=None):
        if save_mat:
            scipy.io.savemat(save_mat, self._linear_program._asdict())

        if verbose:
            lp = self._linear_program
            lpSize = len(lp.c), len(lp.b_eq) + len(lp.b_le)
            print('\nDecomposing update formula')
            print('\t{0} values'.format(len(self.values)))
            print('\tsolving {0}x{1} linear program'.format(*lpSize))
            sys.stdout.flush()

        self._solve_linear_program_glpk(verbose>1)

        if verbose:
            res = self._linear_program_result
            print('Decomposed into {0} atomic stages'.format(res.x[-1] + 1))
            print('\tobjective function = {0}'.format(res.obj))
            print('\tstatus: ' + res.status)
            sys.stdout.flush()

    # --------------------------------------------------------------------- #

    def _assign_lp_results_to_vars(self):
        self.numStages = int(self._linear_program_result.x[-1]) + 1
        c, k, g = self._linear_program_result.x[:-1].reshape([3,-1])
        assert c.size == len(self.values)
        assert g.max() <= 1

        for i, a in enumerate(self.values):
            a = self.values[i]
            a.createStage = int(round(c[i]))
            a.killStage = int(round(k[i]))
            a.hasNeighbor = (round(g[i]) == 0)

    # --------------------------------------------------------------------- #

    def __init__(self, func, inputs, verbose=True, save_mat=None):
        self._build_computational_graph(func, inputs)
        self._assign_id_to_values()
        self._build_linear_program()
        self._solve_linear_program(verbose, save_mat)
        self._assign_lp_results_to_vars()

        self.stages = [Stage(self.values, self.inputs, self.outputs,
                       k, self.numStages) for k in range(self.numStages)]

    # --------------------------------------------------------------------- #

    def __len__(self):
        return len(self.stages)

    def __iter__(self):
        for s in self.stages:
            yield s

    def __getitem__(self, i):
        return self.stages[i]


# ============================================================================ #
#                                atomic stage                                  #
# ============================================================================ #

class Stage(object):
    def __init__(self, values, globalInputs, globalOutputs, k, K):
        assert k >= 0 and k < K
        self.k = k

        isIn = lambda a : a.createStage < k and a.killStage >= k
        isOut = lambda a : a.createStage <= k and a.killStage > k

        self.inputs = tuple(filter(isIn, values)) \
            if k > 0 else globalInputs
        self.outputs = tuple(filter(isOut, values)) \
            if k < K - 1 else globalOutputs

        isKSource = lambda a : a.createStage == k and a.owner is None and \
                               a not in globalInputs
        self.sourceValues = tuple(filter(isKSource, values))

        isKVar = lambda a : a.createStage == k and a.owner is not None
        self._order_values(list(filter(isKVar, values)))

    def _order_values(self, stage_k_values):
        self.orderedValues = []
        while stage_k_values:
            numRemoved = 0
            for a in stage_k_values:
                isReady = lambda b : b in self.orderedValues or \
                                     b in self.inputs or \
                                     b in self.sourceValues
                a_inputs = filter(_is_like_sa_value, a.owner.inputs)
                if all([isReady(b) for b in a_inputs]):
                    self.orderedValues.append(a)
                    stage_k_values.remove(a)
                    numRemoved += 1
            assert numRemoved > 0

    # --------------------------------------------------------------------- #

    def unstack_input(self, input_new_nbr, input_old_nbr):
        old_nbr = lambda inp : inp.createStage < self.k - 1 or inp.hasNeighbor
        input_objects = [None] * len(self.inputs)

        ptr = 0
        for i, inp in enumerate(self.inputs):
            if not old_nbr(inp):
                inp_obj = input_new_nbr[ptr : ptr + inp.size]
                ptr += inp.size
                input_objects[i] = inp_obj.reshape(inp.shape)
        assert ptr == input_new_nbr.size

        ptr = 0
        for i, inp in enumerate(self.inputs):
            if old_nbr(inp):
                inp_obj = input_old_nbr[ptr : ptr + inp.size]
                ptr += inp.size
                input_objects[i] = inp_obj.reshape(inp.shape)
        assert ptr == input_old_nbr.size

        return input_objects

    def stack_output(self, output_objects):
        context = _infer_context(output_objects[0])
        has_nbr = lambda out : out.createStage < self.k or out.hasNeighbor

        size_no_nbr = builtins.sum(out.size for out in self.outputs \
                                   if not has_nbr(out))
        output_no_nbr = context.zeros(size_no_nbr)
        ptr = 0
        for out, out_obj in zip(self.outputs, output_objects):
            assert out.shape == out_obj.shape
            if not has_nbr(out):
                output_no_nbr[ptr : ptr + out.size] = out_obj.reshape(out.size)
                ptr += out.size
        assert output_no_nbr.size == ptr

        size_has_nbr = builtins.sum(out.size for out in self.outputs \
                                    if has_nbr(out))
        if size_has_nbr == 0:
            return output_no_nbr

        output_has_nbr = context.zeros(size_has_nbr)
        ptr = 0
        for out, out_obj in zip(self.outputs, output_objects):
            assert out.shape == out_obj.shape
            if has_nbr(out):
                output_has_nbr[ptr : ptr + out.size] = out_obj.reshape(out.size)
                ptr += out.size
        assert output_has_nbr.size == ptr

        return output_no_nbr, output_has_nbr

    def __call__(self, input_objects, source_objects=()):
        assert len(input_objects) == len(self.inputs)
        for a, a_obj in zip(self.inputs, input_objects):
            assert not hasattr(a, '_obj')
            a._obj = a_obj

        for a, a_obj in zip(self.sourceValues, source_objects):
            assert not hasattr(a, '_obj')
            a._obj = a_obj

        for a in self.orderedValues:
            assert not hasattr(a, '_obj')
            a_inputs = filter(_is_like_sa_value, a.owner.inputs)
            assert all([hasattr(b, '_obj') for b in a_inputs])
            extract_obj = lambda b : b._obj if _is_like_sa_value(b) else b
            a_input_objects = tuple(extract_obj(b) for b in a.owner.inputs)
            a._obj = a.owner.perform(a_input_objects)

        assert all([hasattr(a, '_obj') for a in self.outputs])
        output_objects = tuple(a._obj for a in self.outputs)

        for a in self.inputs:
            del a._obj
        for a in self.sourceValues:
            del a._obj
        for a in self.orderedValues:
            del a._obj

        return output_objects


# ============================================================================ #
#                                 unit tests                                   #
# ============================================================================ #

class _TestMisc(unittest.TestCase):
    def testPrint(self):
        a = stencil_array()
        b = a * 2
        print(a, b)

    def testPowerClass(self):
        class PowerClass(object):
            __array_priority__ = 10000000
            __add__ = lambda self, a : 1
            __rmul__ = lambda self, a : 2
            __truediv__ = lambda self, a : 3
            __rtruediv__ = lambda self, a : 4
            __pow__ = lambda self, a : 5
            __rpow__ = lambda self, a : 6
            __sub__ = lambda self, a : 7
            __rsub__ = lambda self, a : 8

        a = PowerClass()
        b = stencil_array()
        self.assertEqual(a + b, 1)
        self.assertEqual(b + a, 1)
        self.assertEqual(a - b, 7)
        self.assertEqual(b - a, 8)
        self.assertEqual(a * b, 2)
        self.assertEqual(b * a, 2)
        self.assertEqual(a / b, 3)
        self.assertEqual(b / a, 4)
        self.assertEqual(a ** b, 5)
        self.assertEqual(b ** a, 6)

# ============================================================================ #

class _TestSimpleUpdates(unittest.TestCase):
    def test1(self):
        def update(u):
            return u.ndim + 2**u

        Ni, Nj = 4, 8
        G = sa2d_single_thread.grid2d(Ni, Nj)
        stages = decompose(update, stencil_array())

        self.assertEqual(len(stages), 1)
        stage0 = stages[0]

        u0 = G.i
        result = stage0((u0,))
        self.assertEqual(len(result), 1)
        result = result[0]
        err = result - update(u0)
        self.assertAlmostEqual(0, G.reduce_sum(err**2))

    def test2(self):
        def update(u):
            return u.size - 1 / (-u)**3 * 2

        Ni, Nj = 4, 8
        G = sa2d_single_thread.grid2d(Ni, Nj)
        stages = decompose(update, stencil_array((2,)))

        self.assertEqual(len(stages), 1)
        stage0 = stages[0]

        u0 = G.i + G.ones(2)
        result = stage0((u0,))
        self.assertEqual(len(result), 1)
        result = result[0]
        err = result - update(u0)
        self.assertAlmostEqual(0, G.reduce_sum((err**2).sum()))

    def testExpCopySumMean(self):
        def update(u):
            return G.exp(u).copy().sum(0).mean()

        G = sys.modules[__name__]
        stages = decompose(update, stencil_array((2,3)))

        self.assertEqual(len(stages), 1)
        stage0 = stages[0]

        Ni, Nj = 4, 8
        G = sa2d_single_thread.grid2d(Ni, Nj)
        u0 = G.i + G.ones((2,3)) + np.arange(3)
        result = stage0((u0,))
        self.assertEqual(len(result), 1)
        result = result[0]
        err = result - update(u0)
        self.assertAlmostEqual(0, G.reduce_sum((err**2).sum()))

    def testTransposeReshapeRoll(self):
        def update(u):
            return G.roll(u.transpose([1,0,2]).reshape([3,-1]).T, 1)

        G = sys.modules[__name__]
        stages = decompose(update, stencil_array((2,3,4)))

        self.assertEqual(len(stages), 1)
        stage0 = stages[0]

        Ni, Nj = 4, 8
        G = sa2d_single_thread.grid2d(Ni, Nj)
        u0 = G.i + G.ones((2,3,4)) + np.arange(4)
        result = stage0((u0,))
        self.assertEqual(len(result), 1)
        result = result[0]
        err = result - update(u0)
        self.assertAlmostEqual(0, G.reduce_sum((err**2).sum()))

    def testSetGetItem(self):
        def update(u):
            v = G.zeros([3,2])
            v[0] = G.ones(2)
            v[1,0] = u[0]
            v[2] = u.x_p + u.x_m - 2 * u
            return v

        G = sys.modules[__name__]
        stages = decompose(update, [0,0])

        self.assertEqual(len(stages), 1)
        stage0 = stages[0]

        self.assertEqual(stage0.sourceValues, (G_ZERO,))

        Ni, Nj = 4, 8
        G = sa2d_single_thread.grid2d(Ni, Nj)
        u0 = G.i + np.arange(2) * 8

        result = stage0((u0,), (G.zeros(),))
        self.assertEqual(len(result), 1)
        result = result[0]

        err = result - update(u0)
        self.assertAlmostEqual(0, G.reduce_sum((err**2).sum()))


# ============================================================================ #

class _TestSingleStage(unittest.TestCase):
    def testHeat(self):
        def heat(u):
            dx, dt = 0.1, 0.01
            return u + dt * (u.x_m + u.x_p + u.y_m + u.y_p - 4 * u) / dx**2

        G = sys.modules[__name__]
        heatStages = decompose(heat, stencil_array())

        self.assertEqual(len(heatStages), 1)
        stage0 = heatStages[0]

        Ni, Nj = 16, 8
        G = sa2d_single_thread.grid2d(Ni, Nj)
        u0 = G.ones(())
        result = stage0((u0,))
        self.assertEqual(len(result), 1)
        result = result[0]
        err = result - 1
        self.assertAlmostEqual(0, G.reduce_sum(err**2))

        u0 = G.sin(G.i / Ni * np.pi * 2)
        result = stage0((u0,))
        self.assertEqual(len(result), 1)
        result = result[0]
        err = result - heat(u0)
        self.assertAlmostEqual(0, G.reduce_sum(err**2))

        u0 = G.sin(G.j / Nj * np.pi * 4)
        result = stage0((u0,))
        self.assertEqual(len(result), 1)
        result = result[0]
        err = result - heat(u0)
        self.assertAlmostEqual(0, G.reduce_sum(err**2))

    def testODE1(self):
        def ode(u):
            dt = 0.1
            return u - dt * G.sin(u)

        G = sys.modules[__name__]
        odeStages = decompose(ode, stencil_array())

        self.assertEqual(len(odeStages), 1)
        stage0 = odeStages[0]

        Ni, Nj = 4, 8
        G = sa2d_single_thread.grid2d(Ni, Nj)
        u0 = G.i
        result = stage0((u0,))
        self.assertEqual(len(result), 1)
        result = result[0]
        err = result - ode(u0)
        self.assertAlmostEqual(0, G.reduce_sum(err**2))

    def testODE2(self):
        def ode(u):
            dt = 0.1
            return u - dt * G.cos(u) / len(u)

        G = sys.modules[__name__]
        odeStages = decompose(ode, stencil_array())

        self.assertEqual(len(odeStages), 1)
        stage0 = odeStages[0]

        Ni, Nj = 4, 8
        G = sa2d_single_thread.grid2d(Ni, Nj)
        u0 = G.i
        result = stage0((u0,))
        self.assertEqual(len(result), 1)
        result = result[0]
        err = result - ode(u0)
        self.assertAlmostEqual(0, G.reduce_sum(err**2))


# ============================================================================ #

class _TestMultiStage(unittest.TestCase):
    def testHeat(self):
        def heatMidpoint(u):
            dx, dt = 0.1, 0.01
            uh = u + 0.5 * dt * (u.x_m + u.x_p + u.y_m + u.y_p - 4 * u) / dx**2
            return u + dt * (uh.x_m + uh.x_p + uh.y_m + uh.y_p - 4 * uh) / dx**2

        G = sys.modules[__name__]
        heatStages = decompose(heatMidpoint, stencil_array())

        self.assertEqual(len(heatStages), 2)
        stage0, stage1 = heatStages

        Ni, Nj = 16, 8
        G = sa2d_single_thread.grid2d(Ni, Nj)
        u0 = G.sin(G.i / Ni * np.pi * 2)
        result = stage1(stage0((u0,)))
        self.assertEqual(len(result), 1)
        result = result[0]

        err = result - heatMidpoint(u0)
        self.assertAlmostEqual(G.reduce_sum(err**2), 0)

    def testKuramotoSivashinskyRk4(self):
        def ks_dudt(u):
            dx = 0.1
            lu = (u.x_m + u.x_p + u.y_m + u.y_p - 4 * u) / dx**2
            llu = (lu.x_m + lu.x_p + lu.y_m + lu.y_p - 4 * u) / dx**2
            ux = (u.x_m - u.x_p) / dx
            return -llu - lu - ux * u

        def ks_rk4(u0):
            dt = 0.01
            du0 = dt * ks_dudt(u0)
            du1 = dt * ks_dudt(u0 + 0.5 * du0)
            du2 = dt * ks_dudt(u0 + 0.5 * du1)
            du3 = dt * ks_dudt(u0 + du2)
            return u0 + (du0 + 2 * du1 + 2 * du2 + du3) / 6

        ksStages = decompose(ks_rk4, stencil_array())

        self.assertEqual(len(ksStages), 8)

        Ni, Nj = 16, 8
        G = sa2d_single_thread.grid2d(Ni, Nj)
        u0 = G.sin(G.i / Ni * np.pi * 2)
        inp = (u0,)
        for i in range(8):
            inp = ksStages[i](inp)

        result, = inp
        err = result - ks_rk4(u0)
        self.assertAlmostEqual(G.reduce_sum(err**2), 0)


# ============================================================================ #

def ij_np(i0, i1, j0, j1):
    return np.outer(np.arange(i0, i1), np.ones(j1 - j0, int)), \
           np.outer(np.ones(i1 - i0, int), np.arange(j0, j1))

def runStages(stages, u0, source_dict):
    import sa2d_theano
    Ni = u0.shape[0] - 2
    Nj = u0.shape[1] - 2
    stage_in = [u0]
    for k, stage in enumerate(stages):
        print('Compiling and running atomic stage {0}'.format(k))
        n = len(stage_in)

        def stage_func(stage_in):
            in_obj, src_obj = stage_in[:n], stage_in[n:]
            if k > 0:
                in_obj = stage.unstack_input(*tuple(in_obj))
            out_obj = stage(in_obj, src_obj)
            if k < len(stages) - 1:
                out_obj = stage.stack_output(out_obj)
            return out_obj

        stage_in = stage_in + [source_dict[s] for s in stage.sourceValues]
        compiled_stage = sa2d_theano.compile(stage_func, stage_in)
        stage_out = compiled_stage(*stage_in)

        if k == len(stages) - 1:
            break

        out_no_nbr = stage_out[0]
        assert out_no_nbr.ndim == 3
        assert out_no_nbr.shape[:2] == (Ni, Nj)
        if len(stage_out) > 1:
            assert len(stage_out) == 2
            assert stage_out[1].shape[:2] == (Ni + 2, Nj + 2)

        out_new_nbr = np.zeros((Ni+2, Nj+2, out_no_nbr.shape[2]))
        out_new_nbr[1:-1,1:-1] = out_no_nbr
        out_new_nbr[0,1:-1] = out_no_nbr[-1,:]
        out_new_nbr[-1,1:-1] = out_no_nbr[0,:]
        out_new_nbr[1:-1,0] = out_no_nbr[:,-1]
        out_new_nbr[1:-1,-1] = out_no_nbr[:,0]

        stage_in = list(stage_out)
        stage_in[0] = out_new_nbr

    return stage_out

# ---------------------------------------------------------------------------- #

class _TestTheano(unittest.TestCase):
    def testHeat(self):
        f = stencil_array()

        def heat(u):
            dx = 0.1
            return (u.x_m + u.x_p + u.y_m + u.y_p - 4 * u) / dx**2 + f

        def heatMidpoint(u):
            dt = 0.01
            return u + dt * heat(u)

        heatStages = decompose(heatMidpoint, stencil_array())

        Ni, Nj = 8, 8
        i, j = ij_np(-1, Ni+1, -1, Nj+1)
        u0 = np.sin(i / Ni * np.pi * 2)
        f0 = u0 * 0

        u1, = runStages(heatStages, u0, {f.value: f0})

        dudt = 2 * (1 - np.cos(np.pi * 2 / Ni))
        err = u1 - u0[1:-1,1:-1] * (1 - dudt)

        self.assertAlmostEqual(0, np.abs(err).max())

    def testHeatTwoStage(self):
        f = stencil_array()

        def heat(u):
            dx = 0.1
            return (u.x_m + u.x_p + u.y_m + u.y_p - 4 * u) / dx**2 + f

        def heatMidpoint(u):
            dt = 0.01
            uh = u + 0.5 * dt * heat(u)
            return u + dt * heat(uh)

        heatStages = decompose(heatMidpoint, stencil_array())

        Ni, Nj = 8, 8
        i, j = ij_np(-1, Ni+1, -1, Nj+1)
        u0 = np.sin(i / Ni * np.pi * 2)
        f0 = u0 * 0

        u1, = runStages(heatStages, u0, {f.value: f0})

        dudt = 2 * (1 - np.cos(np.pi * 2 / Ni))
        err = u1 - u0[1:-1,1:-1] * (1 - dudt + dudt**2 / 2)

        self.assertAlmostEqual(0, np.abs(err).max())

    def testKuramotoSivashinskyRk4(self):
        f = stencil_array()

        def ks_dudt(u):
            dx = 0.1
            lu = (u.x_m + u.x_p + u.y_m + u.y_p - 4 * u) / dx**2
            llu = (lu.x_m + lu.x_p + lu.y_m + lu.y_p - 4 * u) / dx**2
            ux = (u.x_m - u.x_p) / dx
            return -llu - lu - ux * u + f

        def ks_rk4(u0):
            dt = 0.01
            du0 = dt * ks_dudt(u0)
            du1 = dt * ks_dudt(u0 + 0.5 * du0)
            du2 = dt * ks_dudt(u0 + 0.5 * du1)
            du3 = dt * ks_dudt(u0 + du2)
            return u0 + (du0 + 2 * du1 + 2 * du2 + du3) / 6

        ksStages = decompose(ks_rk4, stencil_array())

        Ni, Nj = 8, 8
        i, j = ij_np(-1, Ni+1, -1, Nj+1)
        u0 = np.sin(i / Ni * np.pi * 2)
        f0 = u0 * 0

        u1, = runStages(ksStages, u0, {f.value: f0})


# ============================================================================ #

class _TestEuler(unittest.TestCase):
    def testTunnelRk4(self):

        DISS_COEFF = 0.0025
        gamma, R = 1.4, 287.
        T0, p0, M0 = 300., 101325., 0.25

        rho0 = p0 / (R * T0)
        c0 = np.sqrt(gamma * R * T0)
        u0 = c0 * M0
        w0 = np.array([np.sqrt(rho0), np.sqrt(rho0) * u0, 0., p0])

        Lx, Ly = 40., 10.
        dx = dy = 0.05
        dt = dx / c0 * 0.5

        Ni, Nj = 16, 8
        G = sa2d_single_thread.grid2d(Ni, Nj)

        x = (G.i + 0.5) * dx - 0.2 * Lx
        y = (G.j + 0.5) * dy - 0.5 * Ly

        obstacle = G.exp(-((x**2 + y**2) / 1)**64)
        fan = 2 * G.cos((x / Lx + 0.2) * np.pi)**64

        def diffx(w):
            return (w.x_p - w.x_m) / (2 * dx)

        def diffy(w):
            return (w.y_p - w.y_m) / (2 * dy)

        def dissipation(r, u, dc):
            # conservative, negative definite dissipation applied to r*d(ru)/dt
            laplace = lambda u : (u.x_p + u.x_m + u.y_p + u.y_m) * 0.25 - u
            return laplace(dc * r * r * laplace(u))

        def rhs(w):
            r, ru, rv, p = w
            u, v = ru / r, rv / r

            mass = diffx(r * ru) + diffy(r * rv)
            momentum_x = (diffx(ru*ru) + (r*ru) * diffx(u)) / 2.0 \
                       + (diffy(rv*ru) + (r*rv) * diffy(u)) / 2.0 \
                       + diffx(p)
            momentum_y = (diffx(ru*rv) + (r*ru) * diffx(v)) / 2.0 \
                       + (diffy(rv*rv) + (r*rv) * diffy(v)) / 2.0 \
                       + diffy(p)
            energy = gamma * (diffx(p * u) + diffy(p * v)) \
                   - (gamma - 1) * (u * diffx(p) + v * diffy(p))

            one = _infer_context(w).ones(r.shape)
            dissipation_x = dissipation(r, u, DISS_COEFF) * c0 / dx
            dissipation_y = dissipation(r, v, DISS_COEFF) * c0 / dy
            dissipation_p = dissipation(one, p, DISS_COEFF) * c0 / dx

            momentum_x += dissipation_x
            momentum_y += dissipation_y
            energy += dissipation_p \
                    - (gamma - 1) * (u * dissipation_x + v * dissipation_y)

            rhs_w = _infer_context(w).zeros(w.shape)
            rhs_w[0] = 0.5 * mass / r
            rhs_w[1] = momentum_x / r
            rhs_w[2] = momentum_y / r
            rhs_w[-1] = energy

            rhs_w[1:3] += 0.1 * c0 * obstacle * w[1:3]
            rhs_w += 0.1 * c0 * (w - w0) * fan

            return rhs_w

        def step(w):
            dw0 = -dt * rhs(w)
            dw1 = -dt * rhs(w + 0.5 * dw0)
            dw2 = -dt * rhs(w + 0.5 * dw1)
            dw3 = -dt * rhs(w + dw2)
            return w + (dw0 + dw3) / 6 + (dw1 + dw2) / 3

        stages = decompose(step, stencil_array((4,)), save_mat='euler.mat')
        self.assertEqual(len(stages), 8)

        w0 = G.zeros(4) + np.array([np.sqrt(rho0), np.sqrt(rho0) * u0, 0., p0])
        inp = (w0,)
        z = G.zeros(())
        for stage in stages:
            inp = stage(inp, (z,))

        result, = inp
        err = result - step(w0)
        self.assertAlmostEqual(G.reduce_sum(err**2).sum(), 0)

    def testTunnelRk4Theano(self):

        DISS_COEFF = 0.0025
        gamma, R = 1.4, 287.
        T0, p0, M0 = 300., 101325., 0.25

        rho0 = p0 / (R * T0)
        c0 = np.sqrt(gamma * R * T0)
        u0 = c0 * M0
        w0 = np.array([np.sqrt(rho0), np.sqrt(rho0) * u0, 0., p0])

        Lx, Ly = 40., 10.
        dx = dy = 0.05
        dt = dx / c0 * 0.5

        Ni, Nj = 8, 8

        i, j = stencil_array(), stencil_array()
        x = (i + 0.5) * dx - 0.2 * Lx
        y = (j + 0.5) * dy - 0.5 * Ly

        obstacle = exp(-((x**2 + y**2) / 1)**64)
        fan = 2 * cos((x / Lx + 0.2) * np.pi)**64

        def diffx(w):
            return (w.x_p - w.x_m) / (2 * dx)

        def diffy(w):
            return (w.y_p - w.y_m) / (2 * dy)

        def dissipation(r, u, dc):
            # conservative, negative definite dissipation applied to r*d(ru)/dt
            laplace = lambda u : (u.x_p + u.x_m + u.y_p + u.y_m) * 0.25 - u
            return laplace(dc * r * r * laplace(u))

        def rhs(w):
            r, ru, rv, p = w
            u, v = ru / r, rv / r

            mass = diffx(r * ru) + diffy(r * rv)
            momentum_x = (diffx(ru*ru) + (r*ru) * diffx(u)) / 2.0 \
                       + (diffy(rv*ru) + (r*rv) * diffy(u)) / 2.0 \
                       + diffx(p)
            momentum_y = (diffx(ru*rv) + (r*ru) * diffx(v)) / 2.0 \
                       + (diffy(rv*rv) + (r*rv) * diffy(v)) / 2.0 \
                       + diffy(p)
            energy = gamma * (diffx(p * u) + diffy(p * v)) \
                   - (gamma - 1) * (u * diffx(p) + v * diffy(p))

            one = ones(r.shape)
            dissipation_x = dissipation(r, u, DISS_COEFF) * c0 / dx
            dissipation_y = dissipation(r, v, DISS_COEFF) * c0 / dy
            dissipation_p = dissipation(one, p, DISS_COEFF) * c0 / dx

            momentum_x += dissipation_x
            momentum_y += dissipation_y
            energy += dissipation_p \
                    - (gamma - 1) * (u * dissipation_x + v * dissipation_y)

            rhs_w = _infer_context(w).zeros(w.shape)
            rhs_w[0] = 0.5 * mass / r
            rhs_w[1] = momentum_x / r
            rhs_w[2] = momentum_y / r
            rhs_w[-1] = energy

            rhs_w[1:3] += 0.1 * c0 * obstacle * w[1:3]
            rhs_w += 0.1 * c0 * (w - w0) * fan

            return rhs_w

        def step(w):
            dw0 = -dt * rhs(w)
            dw1 = -dt * rhs(w + 0.5 * dw0)
            dw2 = -dt * rhs(w + 0.5 * dw1)
            dw3 = -dt * rhs(w + dw2)
            return w + (dw0 + dw3) / 6 + (dw1 + dw2) / 3

        stages = decompose(step, stencil_array((4,)))
        self.assertEqual(len(stages), 8)

        w0 = np.zeros([Ni+2, Nj+2, 4]) + \
             np.array([np.sqrt(rho0), np.sqrt(rho0) * u0, 0., p0])
        z = np.zeros([Ni+2, Nj+2])
        i0, j0 = np.zeros([2, Ni+2, Nj+2])

        u1, = runStages(stages, w0, {G_ZERO: z, i.value: i0, j.value: j0})
        self.assertEqual(u1.shape, (Ni, Nj, 4))


# ============================================================================ #
#                                                                              #
# ============================================================================ #

if __name__ == '__main__':
    import sa2d_single_thread
    unittest.main()
    # _TestTheano().testHeatTwoStage()
    # _TestEuler().testTunnelRk4()

################################################################################
################################################################################
################################################################################
